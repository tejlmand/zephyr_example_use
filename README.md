This is a small CMake example showing how the use of CMAKE_CURRENT_LIST_DIR without the need for 
special zephyr replacement commands can easily allow for both add_subdirectory but also include 
usage for integrating to Zephyr can be used.

Its main intention is to show that if ${CMAKE_CURRENT_LIST_DIR} is used in Zephyr, we open up for
more flexible re-use of modules, where they can be included both as using include, but also as
add_subdirectory. 

 It uses .config and autoconf.h filesgenerated by Zephyr and KConfig. 
 The include example also shows how compile flags and setting can be configure outside the Zephyr
 project, but still control the build of Zephyr.

Today, Zephyr test if a file added using zephyr_sources is an abolute path or not, and if not, 
prepends the path with ${CMAKE_CURRENT_SOURCE_DIR}.
${CMAKE_CURRENT_SOURCE_DIR} will fail if CMake files are added using include() instead of add_subdirectory.
Wrapping cmakes own target_sources also remove the possibility of using generator expressions.

The two examples also shows a simple use of generator expressions so that files can be included
based on the configuration without the need of creating and maintaining zephyr commands.

Also note, that those changes does not break current Zephyr build, ie. it is still possible to go
directly into Zephyr and build all examples a usual.

############################################################
# example_use_add_sub - start                              #
############################################################

To configure, generator and build, run the folllowing commands, starting from the root folder of
the example, the command below goes for the 'example_use_add_sub'.

    source zephyr/zephyr-env.sh
    mkdir build
    cd build
    cmake -GNinja -DCMAKE_TOOLCHAIN_FILE=../armgcc_toolchain.cmake ..
    ninja

To generate a dot graph of dependencies while in build folder, execute:

    cmake --graphiz=example_use_sub.dot ..


To minimize the required work for showing this principle, the zephyr, kernel, offsets, and
subsys_net are imported as static libs.
The current executable for the project is disabled, as Zephyr does some late linking processing, in 
terms of how linker script is handled, where setting are passed on command line, as well as startup
files/vector table.
Therefore linking fails if trying to make an executable, so to look at this part, and play around
then you can change the 

    if(False)
to

    if(True)

in peripheral_hr/CMakeLists.txt

############################################################
# example_use_add_sub - end                                #
############################################################

############################################################
# example_use_include - start                              #
############################################################

To configure, generator and build, run the folllowing commands, starting from the root folder of
this example.

    source zephyr/zephyr-env.sh
    mkdir build
    cd build
    cmake -GNinja -DCMAKE_TOOLCHAIN_FILE=../armgcc_toolchain.cmake ../customer_project/bt_peripheral_custom
    ninja

To generate a dot graph of dependencies while in build folder, execute:

    cmake --graphviz=example_use_include.dot ../customer_project/bt_peripheral_custom


To minimize the required work for showing this principle, the zephyr, kernel, offsets, and
subsys_net are imported as static libs.
The current executable for the project is disabled, as Zephyr does some late linking processing, in 
terms of how linker script is handled, where setting are passed on command line, as well as startup
files/vector table.
Therefore linking fails if trying to make an executable, so to look at this part, and play around
then you can change the 

    if(False)
to

    if(True)

in customer_project/peripheral_hr/CMakeLists.txt

############################################################
# example_use_include - end                                #
############################################################

